{"version":3,"file":"martinez.umd.js","sources":["../src/operation.ts","../src/constants.ts","../node_modules/tinyqueue/index.js","../src/edge_type.ts","../src/sweep_event.ts","../src/signed_area.ts","../src/compare_events.ts","../src/fill_queue.ts","../node_modules/splaytree/dist/splay.esm.js","../src/compute_fields.ts","../src/types.ts","../src/divide_segment.ts","../src/intersection.ts","../src/possible_intersection.ts","../src/compare_segments.ts","../src/subdivide_segments.ts","../src/connect_edges.ts","../src/boolean.ts","../src/index.ts"],"sourcesContent":["export const INTERSECTION = 0;\nexport const UNION = 1;\nexport const DIFFERENCE = 2;\nexport const XOR = 3;\n\nenum Operation {\n  INTERSECTION,\n  UNION,\n  DIFFERENCE,\n  XOR,\n};\n\nexport declare type OperationType = 0 | 1 | 2 | 3;\n\nexport default Operation;","import { MultiPolygon } from './types';\n\nexport const PRECISION = 12\nexport const EMPTY:MultiPolygon = [];\nexport const EPS:number = Math.pow(10,-PRECISION);\nexport const E_LIMIT:number = Math.pow(10, PRECISION);\n","\nexport default class TinyQueue {\n    constructor(data = [], compare = defaultCompare) {\n        this.data = data;\n        this.length = this.data.length;\n        this.compare = compare;\n\n        if (this.length > 0) {\n            for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);\n        }\n    }\n\n    push(item) {\n        this.data.push(item);\n        this.length++;\n        this._up(this.length - 1);\n    }\n\n    pop() {\n        if (this.length === 0) return undefined;\n\n        const top = this.data[0];\n        const bottom = this.data.pop();\n        this.length--;\n\n        if (this.length > 0) {\n            this.data[0] = bottom;\n            this._down(0);\n        }\n\n        return top;\n    }\n\n    peek() {\n        return this.data[0];\n    }\n\n    _up(pos) {\n        const {data, compare} = this;\n        const item = data[pos];\n\n        while (pos > 0) {\n            const parent = (pos - 1) >> 1;\n            const current = data[parent];\n            if (compare(item, current) >= 0) break;\n            data[pos] = current;\n            pos = parent;\n        }\n\n        data[pos] = item;\n    }\n\n    _down(pos) {\n        const {data, compare} = this;\n        const halfLength = this.length >> 1;\n        const item = data[pos];\n\n        while (pos < halfLength) {\n            let left = (pos << 1) + 1;\n            let best = data[left];\n            const right = left + 1;\n\n            if (right < this.length && compare(data[right], best) < 0) {\n                left = right;\n                best = data[right];\n            }\n            if (compare(best, item) >= 0) break;\n\n            data[pos] = best;\n            pos = left;\n        }\n\n        data[pos] = item;\n    }\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n","export const NORMAL               = 0;\nexport const NON_CONTRIBUTING     = 1;\nexport const SAME_TRANSITION      = 2;\nexport const DIFFERENT_TRANSITION = 3;\n\n","import { Point } from './types';\nimport { NORMAL } from './edge_type';\n\nexport default class SweepEvent {\n  public left:boolean;\n  public isSubject:boolean;\n  public point:Point;\n  public otherEvent:SweepEvent;\n  public type:number;\n  /** @internal */\n  public pos?:number;\n\n  // transition flags\n  public inOut:boolean = false;\n  public otherInOut:boolean = false;\n  public prevInResult:SweepEvent|null = null;\n  // Does event belong to result?\n  public inResult:boolean = false;\n\n  // connection step\n  public resultInOut:boolean = false;\n  public isExteriorRing:boolean = true;\n  public contourId:number = -1;\n\n  constructor (\n    point:Point, \n    left:boolean, \n    otherEvent:SweepEvent|null, \n    isSubject:boolean, \n    edgeType:number = NORMAL\n  ) {\n    // Is left endpoint?\n    this.left = left;\n    this.point = point;\n\n    // Other edge reference\n    this.otherEvent = otherEvent;\n    // Belongs to source or clipping polygon\n    this.isSubject = isSubject;\n\n    // Edge contribution type\n    this.type = edgeType;\n  }\n\n\n  isVertical ():boolean {\n    return this.point[0] === this.otherEvent.point[0];\n  }\n\n\n  clone ():SweepEvent {\n    const copy = new SweepEvent(\n      this.point, this.left, this.otherEvent, this.isSubject, this.type);\n\n    copy.inResult       = this.inResult;\n    copy.prevInResult   = this.prevInResult;\n    copy.isExteriorRing = this.isExteriorRing;\n    copy.inOut          = this.inOut;\n    copy.otherInOut     = this.otherInOut;\n\n    return copy;\n  }\n}\n\nexport function isBelow(e:SweepEvent, p:Point):boolean {\n  const p0 = e.point, p1 = e.otherEvent.point;\n  return e.left\n    ? (p0[0] - p[0]) * (p1[1] - p[1]) - (p1[0] - p[0]) * (p0[1] - p[1]) > 0\n    // signedArea(this.point, this.otherEvent.point, p) > 0 :\n    : (p1[0] - p[0]) * (p0[1] - p[1]) - (p0[0] - p[0]) * (p1[1] - p[1]) > 0;\n    //signedArea(this.otherEvent.point, this.point, p) > 0;\n}","import { Point } from './types';\n\n/**\n * Signed area of the triangle (p0, p1, p2)\n */\nexport default function signedArea(p0:Point, p1:Point, p2:Point):number {\n  return (p0[0] - p2[0]) * (p1[1] - p2[1]) - (p1[0] - p2[0]) * (p0[1] - p2[1]);\n}\n","import signedArea from './signed_area';\nimport SweepEvent, { isBelow } from './sweep_event';\n\n/**\n * @param  {SweepEvent} e1\n * @param  {SweepEvent} e2\n * @return {Number}\n */\nexport default function compareEvents(e1:SweepEvent, e2:SweepEvent):(-1|0|1) {\n  const p1 = e1.point;\n  const p2 = e2.point;\n\n  // Different x-coordinate\n  if (p1[0] > p2[0]) return 1;\n  if (p1[0] < p2[0]) return -1;\n\n  // Different points, but same x-coordinate\n  // Event with lower y-coordinate is processed first\n  if (p1[1] !== p2[1]) return p1[1] > p2[1] ? 1 : -1;\n\n  // Same coordinates, but one is a left endpoint and the other is\n  // a right endpoint. The right endpoint is processed first\n  if (e1.left !== e2.left)\n    return e1.left ? 1 : -1;\n\n  // const p2 = e1.otherEvent.point, p3 = e2.otherEvent.point;\n  // const sa = (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n  // Same coordinates, both events\n  // are left endpoints or right endpoints.\n  // not collinear\n  if (signedArea(p1, e1.otherEvent.point, e2.otherEvent.point) !== 0) {\n    // the event associate to the bottom segment is processed first\n    return (!isBelow(e1, e2.otherEvent.point)) ? 1 : -1;\n  }\n\n  return (!e1.isSubject && e2.isSubject) ? 1 : -1;\n}\n","import Queue           from 'tinyqueue';\nimport SweepEvent      from './sweep_event';\nimport compareEvents   from './compare_events';\nimport Operation, { DIFFERENCE }  from './operation';\nimport { \n  MultiPolygon, BoundingBox, \n  Polygon, Contour\n} from './types';\n\nlet contourId = 0;\n\nfunction processPolygon(\n  contourOrHole:Contour, \n  isSubject:boolean, \n  depth:number, \n  Q:Queue<SweepEvent>, \n  bbox:BoundingBox, \n  isExteriorRing:boolean\n) {\n  let i, len, s1, s2, e1, e2;\n  for (i = 0, len = contourOrHole.length - 1; i < len; i++) {\n    s1 = contourOrHole[i];\n    s2 = contourOrHole[i + 1];\n    e1 = new SweepEvent(s1, false, undefined, isSubject);\n    e2 = new SweepEvent(s2, false, e1,        isSubject);\n    e1.otherEvent = e2;\n\n    if (s1[0] === s2[0] && s1[1] === s2[1]) {\n      continue; // skip collapsed edges, or it breaks\n    }\n\n    e1.contourId = e2.contourId = depth;\n    if (!isExteriorRing) {\n      e1.isExteriorRing = false;\n      e2.isExteriorRing = false;\n    }\n\n    if (compareEvents(e1, e2) > 0) e2.left = true;\n    else                           e1.left = true;\n\n    const x = s1[0], y = s1[1];\n    if (x < bbox[0]) bbox[0] = x;\n    if (y < bbox[1]) bbox[1] = y;\n    if (x > bbox[2]) bbox[2] = x;\n    if (y > bbox[3]) bbox[3] = x;\n\n    // Pushing it so the queue is sorted from left to right,\n    // with object on the left having the highest priority.\n    Q.push(e1);\n    Q.push(e2);\n  }\n}\n\n\nexport default function fillQueue(\n  subject:MultiPolygon, \n  clipping:MultiPolygon, \n  sbbox:BoundingBox, \n  cbbox:BoundingBox, \n  operation:Operation\n):Queue<SweepEvent> {\n  const Q = new Queue(undefined, compareEvents);\n  let polygonSet:Polygon, isExteriorRing:boolean, i, ii, j, jj; \n\n  for (i = 0, ii = subject.length; i < ii; i++) {\n    polygonSet = subject[i];\n    for (j = 0, jj = polygonSet.length; j < jj; j++) {\n      isExteriorRing = j === 0;\n      if (isExteriorRing) contourId++;\n      processPolygon(polygonSet[j], true, contourId, Q, sbbox, isExteriorRing);\n    }\n  }\n\n  for (i = 0, ii = clipping.length; i < ii; i++) {\n    polygonSet = clipping[i];\n    for (j = 0, jj = polygonSet.length; j < jj; j++) {\n      isExteriorRing = j === 0;\n      if (operation === DIFFERENCE) isExteriorRing = false;\n      if (isExteriorRing) contourId++;\n      processPolygon(polygonSet[j], false, contourId, Q, cbbox, isExteriorRing);\n    }\n  }\n\n  return Q;\n}\n","/**\n * splaytree v3.0.0\n * Fast Splay tree for Node and browser\n *\n * @author Alexander Milevski <info@w8r.name>\n * @license MIT\n * @preserve\n */\n\nclass Node {\r\n    constructor(key, data) {\r\n        this.next = null;\r\n        this.key = key;\r\n        this.data = data;\r\n        this.left = null;\r\n        this.right = null;\r\n    }\r\n}\n\n/* follows \"An implementation of top-down splaying\"\r\n * by D. Sleator <sleator@cs.cmu.edu> March 1992\r\n */\r\nfunction DEFAULT_COMPARE(a, b) {\r\n    return a > b ? 1 : a < b ? -1 : 0;\r\n}\r\n/**\r\n * Simple top down splay, not requiring i to be in the tree t.\r\n */\r\nfunction splay(i, t, comparator) {\r\n    const N = new Node(null, null);\r\n    let l = N;\r\n    let r = N;\r\n    while (true) {\r\n        const cmp = comparator(i, t.key);\r\n        //if (i < t.key) {\r\n        if (cmp < 0) {\r\n            if (t.left === null)\r\n                break;\r\n            //if (i < t.left.key) {\r\n            if (comparator(i, t.left.key) < 0) {\r\n                const y = t.left; /* rotate right */\r\n                t.left = y.right;\r\n                y.right = t;\r\n                t = y;\r\n                if (t.left === null)\r\n                    break;\r\n            }\r\n            r.left = t; /* link right */\r\n            r = t;\r\n            t = t.left;\r\n            //} else if (i > t.key) {\r\n        }\r\n        else if (cmp > 0) {\r\n            if (t.right === null)\r\n                break;\r\n            //if (i > t.right.key) {\r\n            if (comparator(i, t.right.key) > 0) {\r\n                const y = t.right; /* rotate left */\r\n                t.right = y.left;\r\n                y.left = t;\r\n                t = y;\r\n                if (t.right === null)\r\n                    break;\r\n            }\r\n            l.right = t; /* link left */\r\n            l = t;\r\n            t = t.right;\r\n        }\r\n        else\r\n            break;\r\n    }\r\n    /* assemble */\r\n    l.right = t.left;\r\n    r.left = t.right;\r\n    t.left = N.right;\r\n    t.right = N.left;\r\n    return t;\r\n}\r\nfunction insert(i, data, t, comparator) {\r\n    const node = new Node(i, data);\r\n    if (t === null) {\r\n        node.left = node.right = null;\r\n        return node;\r\n    }\r\n    t = splay(i, t, comparator);\r\n    const cmp = comparator(i, t.key);\r\n    if (cmp < 0) {\r\n        node.left = t.left;\r\n        node.right = t;\r\n        t.left = null;\r\n    }\r\n    else if (cmp >= 0) {\r\n        node.right = t.right;\r\n        node.left = t;\r\n        t.right = null;\r\n    }\r\n    return node;\r\n}\r\nfunction split(key, v, comparator) {\r\n    let left = null;\r\n    let right = null;\r\n    if (v) {\r\n        v = splay(key, v, comparator);\r\n        const cmp = comparator(v.key, key);\r\n        if (cmp === 0) {\r\n            left = v.left;\r\n            right = v.right;\r\n        }\r\n        else if (cmp < 0) {\r\n            right = v.right;\r\n            v.right = null;\r\n            left = v;\r\n        }\r\n        else {\r\n            left = v.left;\r\n            v.left = null;\r\n            right = v;\r\n        }\r\n    }\r\n    return { left, right };\r\n}\r\nfunction merge(left, right, comparator) {\r\n    if (right === null)\r\n        return left;\r\n    if (left === null)\r\n        return right;\r\n    right = splay(left.key, right, comparator);\r\n    right.left = left;\r\n    return right;\r\n}\r\n/**\r\n * Prints level of the tree\r\n */\r\nfunction printRow(root, prefix, isTail, out, printNode) {\r\n    if (root) {\r\n        out(`${prefix}${isTail ? '└── ' : '├── '}${printNode(root)}\\n`);\r\n        const indent = prefix + (isTail ? '    ' : '│   ');\r\n        if (root.left)\r\n            printRow(root.left, indent, false, out, printNode);\r\n        if (root.right)\r\n            printRow(root.right, indent, true, out, printNode);\r\n    }\r\n}\r\nclass Tree {\r\n    constructor(comparator = DEFAULT_COMPARE) {\r\n        this._root = null;\r\n        this._size = 0;\r\n        this._comparator = comparator;\r\n    }\r\n    /**\r\n     * Inserts a key, allows duplicates\r\n     */\r\n    insert(key, data) {\r\n        this._size++;\r\n        return this._root = insert(key, data, this._root, this._comparator);\r\n    }\r\n    /**\r\n     * Adds a key, if it is not present in the tree\r\n     */\r\n    add(key, data) {\r\n        const node = new Node(key, data);\r\n        if (this._root === null) {\r\n            node.left = node.right = null;\r\n            this._size++;\r\n            this._root = node;\r\n        }\r\n        const comparator = this._comparator;\r\n        const t = splay(key, this._root, comparator);\r\n        const cmp = comparator(key, t.key);\r\n        if (cmp === 0)\r\n            this._root = t;\r\n        else {\r\n            if (cmp < 0) {\r\n                node.left = t.left;\r\n                node.right = t;\r\n                t.left = null;\r\n            }\r\n            else if (cmp > 0) {\r\n                node.right = t.right;\r\n                node.left = t;\r\n                t.right = null;\r\n            }\r\n            this._size++;\r\n            this._root = node;\r\n        }\r\n        return this._root;\r\n    }\r\n    /**\r\n     * @param  {Key} key\r\n     * @return {Node|null}\r\n     */\r\n    remove(key) {\r\n        this._root = this._remove(key, this._root, this._comparator);\r\n    }\r\n    /**\r\n     * Deletes i from the tree if it's there\r\n     */\r\n    _remove(i, t, comparator) {\r\n        let x;\r\n        if (t === null)\r\n            return null;\r\n        t = splay(i, t, comparator);\r\n        const cmp = comparator(i, t.key);\r\n        if (cmp === 0) { /* found it */\r\n            if (t.left === null) {\r\n                x = t.right;\r\n            }\r\n            else {\r\n                x = splay(i, t.left, comparator);\r\n                x.right = t.right;\r\n            }\r\n            this._size--;\r\n            return x;\r\n        }\r\n        return t; /* It wasn't there */\r\n    }\r\n    /**\r\n     * Removes and returns the node with smallest key\r\n     */\r\n    pop() {\r\n        let node = this._root;\r\n        if (node) {\r\n            while (node.left)\r\n                node = node.left;\r\n            this._root = splay(node.key, this._root, this._comparator);\r\n            this._root = this._remove(node.key, this._root, this._comparator);\r\n            return { key: node.key, data: node.data };\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Find without splaying\r\n     */\r\n    findStatic(key) {\r\n        let current = this._root;\r\n        const compare = this._comparator;\r\n        while (current) {\r\n            const cmp = compare(key, current.key);\r\n            if (cmp === 0)\r\n                return current;\r\n            else if (cmp < 0)\r\n                current = current.left;\r\n            else\r\n                current = current.right;\r\n        }\r\n        return null;\r\n    }\r\n    find(key) {\r\n        if (this._root) {\r\n            this._root = splay(key, this._root, this._comparator);\r\n            if (this._comparator(key, this._root.key) !== 0)\r\n                return null;\r\n        }\r\n        return this._root;\r\n    }\r\n    contains(key) {\r\n        let current = this._root;\r\n        const compare = this._comparator;\r\n        while (current) {\r\n            const cmp = compare(key, current.key);\r\n            if (cmp === 0)\r\n                return true;\r\n            else if (cmp < 0)\r\n                current = current.left;\r\n            else\r\n                current = current.right;\r\n        }\r\n        return false;\r\n    }\r\n    forEach(visitor, ctx) {\r\n        let current = this._root;\r\n        const Q = []; /* Initialize stack s */\r\n        let done = false;\r\n        while (!done) {\r\n            if (current !== null) {\r\n                Q.push(current);\r\n                current = current.left;\r\n            }\r\n            else {\r\n                if (Q.length !== 0) {\r\n                    current = Q.pop();\r\n                    visitor.call(ctx, current);\r\n                    current = current.right;\r\n                }\r\n                else\r\n                    done = true;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Walk key range from `low` to `high`. Stops if `fn` returns a value.\r\n     */\r\n    range(low, high, fn, ctx) {\r\n        const Q = [];\r\n        const compare = this._comparator;\r\n        let node = this._root;\r\n        let cmp;\r\n        while (Q.length !== 0 || node) {\r\n            if (node) {\r\n                Q.push(node);\r\n                node = node.left;\r\n            }\r\n            else {\r\n                node = Q.pop();\r\n                cmp = compare(node.key, high);\r\n                if (cmp > 0) {\r\n                    break;\r\n                }\r\n                else if (compare(node.key, low) >= 0) {\r\n                    if (fn.call(ctx, node))\r\n                        return this; // stop if smth is returned\r\n                }\r\n                node = node.right;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns array of keys\r\n     */\r\n    keys() {\r\n        const keys = [];\r\n        this.forEach(({ key }) => keys.push(key));\r\n        return keys;\r\n    }\r\n    /**\r\n     * Returns array of all the data in the nodes\r\n     */\r\n    values() {\r\n        const values = [];\r\n        this.forEach(({ data }) => values.push(data));\r\n        return values;\r\n    }\r\n    min() {\r\n        if (this._root)\r\n            return this.minNode(this._root).key;\r\n        return null;\r\n    }\r\n    max() {\r\n        if (this._root)\r\n            return this.maxNode(this._root).key;\r\n        return null;\r\n    }\r\n    minNode(t = this._root) {\r\n        if (t)\r\n            while (t.left)\r\n                t = t.left;\r\n        return t;\r\n    }\r\n    maxNode(t = this._root) {\r\n        if (t)\r\n            while (t.right)\r\n                t = t.right;\r\n        return t;\r\n    }\r\n    /**\r\n     * Returns node at given index\r\n     */\r\n    at(index) {\r\n        let current = this._root;\r\n        let done = false;\r\n        let i = 0;\r\n        const Q = [];\r\n        while (!done) {\r\n            if (current) {\r\n                Q.push(current);\r\n                current = current.left;\r\n            }\r\n            else {\r\n                if (Q.length > 0) {\r\n                    current = Q.pop();\r\n                    if (i === index)\r\n                        return current;\r\n                    i++;\r\n                    current = current.right;\r\n                }\r\n                else\r\n                    done = true;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    next(d) {\r\n        let root = this._root;\r\n        let successor = null;\r\n        if (d.right) {\r\n            successor = d.right;\r\n            while (successor.left)\r\n                successor = successor.left;\r\n            return successor;\r\n        }\r\n        const comparator = this._comparator;\r\n        while (root) {\r\n            const cmp = comparator(d.key, root.key);\r\n            if (cmp === 0)\r\n                break;\r\n            else if (cmp < 0) {\r\n                successor = root;\r\n                root = root.left;\r\n            }\r\n            else\r\n                root = root.right;\r\n        }\r\n        return successor;\r\n    }\r\n    prev(d) {\r\n        let root = this._root;\r\n        let predecessor = null;\r\n        if (d.left !== null) {\r\n            predecessor = d.left;\r\n            while (predecessor.right)\r\n                predecessor = predecessor.right;\r\n            return predecessor;\r\n        }\r\n        const comparator = this._comparator;\r\n        while (root) {\r\n            const cmp = comparator(d.key, root.key);\r\n            if (cmp === 0)\r\n                break;\r\n            else if (cmp < 0)\r\n                root = root.left;\r\n            else {\r\n                predecessor = root;\r\n                root = root.right;\r\n            }\r\n        }\r\n        return predecessor;\r\n    }\r\n    clear() {\r\n        this._root = null;\r\n        this._size = 0;\r\n        return this;\r\n    }\r\n    toList() {\r\n        return toList(this._root);\r\n    }\r\n    /**\r\n     * Bulk-load items. Both array have to be same size\r\n     */\r\n    load(keys, values = [], presort = false) {\r\n        let size = keys.length;\r\n        const comparator = this._comparator;\r\n        // sort if needed\r\n        if (presort)\r\n            sort(keys, values, 0, size - 1, comparator);\r\n        if (this._root === null) { // empty tree\r\n            this._root = loadRecursive(keys, values, 0, size);\r\n            this._size = size;\r\n        }\r\n        else { // that re-builds the whole tree from two in-order traversals\r\n            const mergedList = mergeLists(this.toList(), createList(keys, values), comparator);\r\n            size = this._size + size;\r\n            this._root = sortedListToBST({ head: mergedList }, 0, size);\r\n        }\r\n        return this;\r\n    }\r\n    isEmpty() { return this._root === null; }\r\n    get size() { return this._size; }\r\n    get root() { return this._root; }\r\n    toString(printNode = (n) => String(n.key)) {\r\n        const out = [];\r\n        printRow(this._root, '', true, (v) => out.push(v), printNode);\r\n        return out.join('');\r\n    }\r\n    update(key, newKey, newData) {\r\n        const comparator = this._comparator;\r\n        let { left, right } = split(key, this._root, comparator);\r\n        if (comparator(key, newKey) < 0) {\r\n            right = insert(newKey, newData, right, comparator);\r\n        }\r\n        else {\r\n            left = insert(newKey, newData, left, comparator);\r\n        }\r\n        this._root = merge(left, right, comparator);\r\n    }\r\n    split(key) {\r\n        return split(key, this._root, this._comparator);\r\n    }\r\n}\r\nfunction loadRecursive(keys, values, start, end) {\r\n    const size = end - start;\r\n    if (size > 0) {\r\n        const middle = start + Math.floor(size / 2);\r\n        const key = keys[middle];\r\n        const data = values[middle];\r\n        const node = new Node(key, data);\r\n        node.left = loadRecursive(keys, values, start, middle);\r\n        node.right = loadRecursive(keys, values, middle + 1, end);\r\n        return node;\r\n    }\r\n    return null;\r\n}\r\nfunction createList(keys, values) {\r\n    const head = new Node(null, null);\r\n    let p = head;\r\n    for (let i = 0; i < keys.length; i++) {\r\n        p = p.next = new Node(keys[i], values[i]);\r\n    }\r\n    p.next = null;\r\n    return head.next;\r\n}\r\nfunction toList(root) {\r\n    let current = root;\r\n    const Q = [];\r\n    let done = false;\r\n    const head = new Node(null, null);\r\n    let p = head;\r\n    while (!done) {\r\n        if (current) {\r\n            Q.push(current);\r\n            current = current.left;\r\n        }\r\n        else {\r\n            if (Q.length > 0) {\r\n                current = p = p.next = Q.pop();\r\n                current = current.right;\r\n            }\r\n            else\r\n                done = true;\r\n        }\r\n    }\r\n    p.next = null; // that'll work even if the tree was empty\r\n    return head.next;\r\n}\r\nfunction sortedListToBST(list, start, end) {\r\n    const size = end - start;\r\n    if (size > 0) {\r\n        const middle = start + Math.floor(size / 2);\r\n        const left = sortedListToBST(list, start, middle);\r\n        const root = list.head;\r\n        root.left = left;\r\n        list.head = list.head.next;\r\n        root.right = sortedListToBST(list, middle + 1, end);\r\n        return root;\r\n    }\r\n    return null;\r\n}\r\nfunction mergeLists(l1, l2, compare) {\r\n    const head = new Node(null, null); // dummy\r\n    let p = head;\r\n    let p1 = l1;\r\n    let p2 = l2;\r\n    while (p1 !== null && p2 !== null) {\r\n        if (compare(p1.key, p2.key) < 0) {\r\n            p.next = p1;\r\n            p1 = p1.next;\r\n        }\r\n        else {\r\n            p.next = p2;\r\n            p2 = p2.next;\r\n        }\r\n        p = p.next;\r\n    }\r\n    if (p1 !== null) {\r\n        p.next = p1;\r\n    }\r\n    else if (p2 !== null) {\r\n        p.next = p2;\r\n    }\r\n    return head.next;\r\n}\r\nfunction sort(keys, values, left, right, compare) {\r\n    if (left >= right)\r\n        return;\r\n    const pivot = keys[(left + right) >> 1];\r\n    let i = left - 1;\r\n    let j = right + 1;\r\n    while (true) {\r\n        do\r\n            i++;\r\n        while (compare(keys[i], pivot) < 0);\r\n        do\r\n            j--;\r\n        while (compare(keys[j], pivot) > 0);\r\n        if (i >= j)\r\n            break;\r\n        let tmp = keys[i];\r\n        keys[i] = keys[j];\r\n        keys[j] = tmp;\r\n        tmp = values[i];\r\n        values[i] = values[j];\r\n        values[j] = tmp;\r\n    }\r\n    sort(keys, values, left, j, compare);\r\n    sort(keys, values, j + 1, right, compare);\r\n}\n\nexport default Tree;\n//# sourceMappingURL=splay.esm.js.map\n","import {\n  NORMAL,\n  SAME_TRANSITION,\n  DIFFERENT_TRANSITION,\n  NON_CONTRIBUTING\n} from './edge_type';\nimport {\n  INTERSECTION,\n  UNION,\n  DIFFERENCE,\n  XOR,\n  OperationType\n} from './operation';\nimport SweepEvent from './sweep_event';\n\n/**\n * @param  {SweepEvent} event\n * @param  {SweepEvent} prev\n * @param  {Operation} operation\n */\nexport default function computeFields (\n  event:SweepEvent, prev:SweepEvent|null, \n  operation:OperationType\n):void {\n  // compute inOut and otherInOut fields\n  if (prev === null) {\n    event.inOut      = false;\n    event.otherInOut = true;\n\n  // previous line segment in sweepline belongs to the same polygon\n  } else {\n    if (event.isSubject === prev.isSubject) {\n      event.inOut      = !prev.inOut;\n      event.otherInOut = prev.otherInOut;\n\n    // previous line segment in sweepline belongs to the clipping polygon\n    } else {\n      event.inOut      = !prev.otherInOut;\n      event.otherInOut = prev.isVertical() ? !prev.inOut : prev.inOut;\n    }\n\n    // compute prevInResult field\n    if (prev) {\n      event.prevInResult = (!inResult(prev, operation) || prev.isVertical())\n        ? prev.prevInResult : prev;\n    }\n  }\n\n  // check if the line segment belongs to the Boolean operation\n  event.inResult = inResult(event, operation);\n}\n\n\n/* eslint-disable indent */\nfunction inResult(event:SweepEvent, operation:OperationType) {\n  switch (event.type) {\n    case NORMAL:\n      switch (operation) {\n        case INTERSECTION:\n          return !event.otherInOut;\n        case UNION:\n          return event.otherInOut;\n        case DIFFERENCE:\n          // return (event.isSubject && !event.otherInOut) ||\n          //         (!event.isSubject && event.otherInOut);\n          return (event.isSubject && event.otherInOut) ||\n                  (!event.isSubject && !event.otherInOut);\n        case XOR:\n          return true;\n      }\n      break;\n    case SAME_TRANSITION:\n      return operation === INTERSECTION || operation === UNION;\n    case DIFFERENT_TRANSITION:\n      return operation === DIFFERENCE;\n    case NON_CONTRIBUTING:\n      return false;\n  }\n  return false;\n}","export declare type Point = [number, number];\nexport declare type MultiPolygon = Point[][][];\nexport declare type Polygon = Point[][];\nexport declare type Contour = Point[];\nexport declare type BoundingBox = [number, number, number, number];\n\nexport function isPolygon (geometry:Polygon|MultiPolygon): geometry is Polygon {\n  return typeof geometry[0][0][0] === 'number';\n}\n\nexport function equals (a:Point, b:Point):boolean {\n  if (a[0] === b[0]) {\n    if (a[1] === b[1]) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  return false;\n}","import SweepEvent        from './sweep_event';\nimport compareEvents     from './compare_events';\nimport { Point, equals } from './types';\nimport Queue             from 'tinyqueue';\n\nexport default function divideSegment(\n  se:SweepEvent, p:Point, queue:Queue<SweepEvent>\n):Queue<SweepEvent>  {\n  const r = new SweepEvent(p, false, se,            se.isSubject);\n  const l = new SweepEvent(p, true,  se.otherEvent, se.isSubject);\n\n  /* eslint-disable no-console */\n  if (equals(se.point, se.otherEvent.point)) {\n    console.warn('what is that, a collapsed segment?', se);\n  }\n  /* eslint-enable no-console */\n\n  r.contourId = l.contourId = se.contourId;\n\n  // avoid a rounding error. The left event would be processed after the right event\n  if (compareEvents(l, se.otherEvent) > 0) {\n    se.otherEvent.left = true;\n    l.left = false;\n  }\n\n  // avoid a rounding error. The left event would be processed after the right event\n  // if (compareEvents(se, r) > 0) {}\n\n  se.otherEvent.otherEvent = l;\n  se.otherEvent = r;\n\n  queue.push(l);\n  queue.push(r);\n\n  return queue;\n}","import { Point } from './types';\nimport { EPS, E_LIMIT } from './constants';\n\nexport default function intersection(\n  a0x:number, a0y:number, a1x:number, a1y:number,\n  b0x:number, b0y:number, b1x:number, b1y:number,\n  I:[Point, Point]\n):(0|1|2) {\n  const vax = a1x - a0x;\n  const vay = a1y - a0y;\n  const vbx = b1x - b0x; \n  const vby = b1y - b0y;\n  // segments a0 + s * a1 for s in [0, 1], b0 + t * b1 for t in [0,1]\n\n  const ex = b0x - a0x;\n  const ey = b0y - a0y;\n\n  let kross = vax * vby - vay * vbx;\n  let sqrKross = kross * kross;\n\n  const sqrLen0 = vax * vax + vay * vay;\n  // const sqrLen1 = vbx * vbx + vby * vby;\n\n  if (sqrKross > 0) {\n    // lines of the segments are not parallel\n    let s = Math.round((ex * vby - ey * vbx) / kross * E_LIMIT) / E_LIMIT;\n    // intersection is outside the segment [a0, a1]\n    if (s < 0 || s > 1) return 0;\n\n    // precision issues\n    // else if (s < EPS)     s = 0; \n    // else if (1 - s < EPS) s = 1;\n\n    let t = Math.round((ex * vay - ey * vax) / kross * E_LIMIT) / E_LIMIT;\n    // intersection is outside the segment [b0, b1]\n    if (t < 0 || t > 1) return 0;\n\n    // precision issues\n    // else if (t < EPS)     t = 0; \n    // else if (1 - t < EPS) t = 1;\n\n    if (s === 0 || s === 1) {\n      // on an endpoint of line segment a\n      I[0][0] = a0x + s * vax;\n      I[0][1] = a0y + s * vay;\n      return 1;\n    }\n    if (t === 0 || t === 1) {\n      // on an endpoint of line segment b\n      I[0][0] = b0x + t * vbx;\n      I[0][1] = b0y + t * vby;\n      return 1;\n    }\n    \n    // intersection of lines is a point on each segment\n    I[0][0] = a0x + s * vax;\n    I[0][1] = a0y + s * vay;\n    return 1;\n  }\n\n  // lines of the segments are parallel\n  const sqrLenE = ex * ex + ey * ey;\n  kross = ex * vay - ey * vax;\n  sqrKross = kross * kross;\n  if (sqrKross > EPS * sqrLen0 * sqrLenE) {\n    // lines of the segments are different\n    return 0;\n  }\n  // Lines of the segments are the same.  Need to test for overlap of\n  // segments.\n\n  const s0 = ((vax * ex) + (vay * ey)) / sqrLen0;\n  const s1 = s0 + ((vax * vbx) + (vay * vby)) / sqrLen0;\n\n  const smin = Math.min(s0, s1);\n  const smax = Math.max(s0, s1);\n\n  // this is, essentially, the FindIntersection acting on floats from\n  // Schneider & Eberly, just inlined into this function.\n  if (smin <= 1 && smax >= 0) {\n    // overlap on an end point\n    if (smin === 1) {\n      const c = Math.max(smin, 0);\n      I[0][0] = a0x + c * vax; \n      I[0][1] = a0y + c * vay;\n      return 1;\n    }\n\n    if (smax === 0) {\n      const c = Math.min(smax, 1);\n      I[0][0] = a0x + c * vax;\n      I[0][1] = a0y + c * vay;\n      return 1;\n    }\n\n    // There's overlap on a segment -- two points of intersection. Return both.\n    const cmin = Math.max(smin, 0), cmax = Math.min(smax, 1);\n    I[0][0] = a0x + cmin * vax;\n    I[0][1] = a0y + cmin * vay;\n    I[1][0] = a0x + cmax * vax; \n    I[1][1] = a0y + cmax * vay;\n    return 2;\n  }\n  return 0;\n}\n","import divideSegment from './divide_segment';\nimport intersection  from './intersection';\nimport compareEvents from './compare_events';\nimport { equals }    from './types';\nimport {\n  NON_CONTRIBUTING,\n  SAME_TRANSITION,\n  DIFFERENT_TRANSITION\n} from './edge_type';\nimport SweepEvent from './sweep_event';\nimport Queue from 'tinyqueue';\n\nconst intersections:[[number, number], [number, number]] = [[0,0],[0,0]];\n\nexport default function possibleIntersection (\n  se1:SweepEvent, se2:SweepEvent,\n  queue:Queue<SweepEvent>\n):0|1|2|3 {\n  // that disallows self-intersecting polygons,\n  // did cost us half a day, so I'll leave it\n  // out of respect\n  // if (se1.isSubject === se2.isSubject) return;\n  const a = se1.point, b = se1.otherEvent.point,\n        c = se2.point, d = se2.otherEvent.point;\n  const nintersections:number = intersection(\n    a[0], a[1], b[0], b[1], \n    c[0], c[1], d[0], d[1],\n    intersections\n  );\n\n  if (nintersections === 0) return 0; // no intersection\n\n  // the line segments intersect at an endpoint of both line segments\n  if ((nintersections === 1) &&\n      (equals(se1.point, se2.point) ||\n       equals(se1.otherEvent.point, se2.otherEvent.point))) {\n    return 0;\n  }\n\n  // best would be to skip it\n  if (nintersections === 2 && se1.isSubject === se2.isSubject) {\n    // if(se1.contourId === se2.contourId){\n    // console.warn('Edges of the same polygon overlap',\n    //   se1.point, se1.otherEvent.point, se2.point, se2.otherEvent.point);\n    // }\n    //throw new Error('Edges of the same polygon overlap');\n    return 0;\n  }\n\n  // The line segments associated to se1 and se2 intersect\n  if (nintersections === 1) {\n\n    // if the intersection point is not an endpoint of se1\n    if (!equals(se1.point, intersections[0]) && !equals(se1.otherEvent.point, intersections[0])) {\n      divideSegment(se1, intersections[0], queue);\n    }\n\n    // if the intersection point is not an endpoint of se2\n    if (!equals(se2.point, intersections[0]) && !equals(se2.otherEvent.point, intersections[0])) {\n      divideSegment(se2, intersections[0], queue);\n    }\n    return 1;\n  }\n\n  // The line segments associated to se1 and se2 overlap\n  const events        = [];\n  let leftCoincide  = false;\n  let rightCoincide = false;\n\n  if (equals(se1.point, se2.point)) {\n    leftCoincide = true; // linked\n  } else if (compareEvents(se1, se2) === 1) {\n    events.push(se2, se1);\n  } else {\n    events.push(se1, se2);\n  }\n\n  if (equals(se1.otherEvent.point, se2.otherEvent.point)) {\n    rightCoincide = true;\n  } else if (compareEvents(se1.otherEvent, se2.otherEvent) === 1) {\n    events.push(se2.otherEvent, se1.otherEvent);\n  } else {\n    events.push(se1.otherEvent, se2.otherEvent);\n  }\n\n  if ((leftCoincide && rightCoincide) || leftCoincide) {\n    // both line segments are equal or share the left endpoint\n    se2.type = NON_CONTRIBUTING;\n    se1.type = (se2.inOut === se1.inOut)\n      ? SAME_TRANSITION : DIFFERENT_TRANSITION;\n\n    if (leftCoincide && !rightCoincide) {\n      // honestly no idea, but changing events selection from [2, 1]\n      // to [0, 1] fixes the overlapping self-intersecting polygons issue\n      divideSegment(events[1].otherEvent, events[0].point, queue);\n    }\n    return 2;\n  }\n\n  // the line segments share the right endpoint\n  if (rightCoincide) {\n    divideSegment(events[0], events[1].point, queue);\n    return 3;\n  }\n\n  // no line segment includes totally the other one\n  if (events[0] !== events[3].otherEvent) {\n    divideSegment(events[0], events[1].point, queue);\n    divideSegment(events[1], events[2].point, queue);\n    return 3;\n  }\n\n  // one line segment includes the other one\n  divideSegment(events[0], events[1].point, queue);\n  divideSegment(events[3].otherEvent, events[2].point, queue);\n\n  return 3;\n}","import signedArea    from './signed_area';\nimport compareEvents from './compare_events';\nimport { equals }    from './types';\nimport SweepEvent, { isBelow } from './sweep_event';\n\n\nexport default function compareSegments(le1:SweepEvent, le2:SweepEvent):number {\n  if (le1 === le2) return 0;\n\n  // Segments are not collinear\n  if (signedArea(le1.point, le1.otherEvent.point, le2.point) !== 0 ||\n    signedArea(le1.point, le1.otherEvent.point, le2.otherEvent.point) !== 0) {\n\n    // If they share their left endpoint use the right endpoint to sort\n    if (equals(le1.point, le2.point)) return isBelow(le1, le2.otherEvent.point) ? -1 : 1;\n\n    // Different left endpoint: use the left endpoint to sort\n    if (le1.point[0] === le2.point[0]) return le1.point[1] < le2.point[1] ? -1 : 1;\n\n    // has the line segment associated to e1 been inserted\n    // into S after the line segment associated to e2 ?\n    if (compareEvents(le1, le2) === 1) return isBelow(le2, le1.point) ? 1 : -1;\n\n    // The line segment associated to e2 has been inserted\n    // into S after the line segment associated to e1\n    return isBelow(le1, le2.point) ? -1 : 1;\n  }\n\n  if (le1.isSubject === le2.isSubject) { // same polygon\n    let p1 = le1.point, p2 = le2.point;\n    if (p1[0] === p2[0] && p1[1] === p2[1]/*equals(le1.point, le2.point)*/) {\n      p1 = le1.otherEvent.point; p2 = le2.otherEvent.point;\n      if (p1[0] === p2[0] && p1[1] === p2[1]) return 0;\n      else return le1.contourId > le2.contourId ? 1 : -1;\n    }\n  } else { // Segments are collinear, but belong to separate polygons\n    return le1.isSubject ? -1 : 1;\n  }\n\n  return compareEvents(le1, le2) === 1 ? 1 : -1;\n}","import Tree                 from 'splaytree';\nimport computeFields        from './compute_fields';\nimport possibleIntersection from './possible_intersection';\nimport compareSegments      from './compare_segments';\nimport {\n  INTERSECTION,\n  DIFFERENCE,\n  OperationType\n} from './operation';\nimport Queue from 'tinyqueue';\nimport SweepEvent from './sweep_event';\nimport { MultiPolygon, BoundingBox } from './types';\n\n\nexport default function subdivide(\n  eventQueue:Queue<SweepEvent>,\n  subject:MultiPolygon, clipping:MultiPolygon,\n  sbbox:BoundingBox, cbbox:BoundingBox,\n  operation:OperationType\n):SweepEvent[] {\n  const sweepLine = new Tree<SweepEvent>(compareSegments);\n  const sortedEvents = [];\n\n  const rightbound = Math.min(sbbox[2], cbbox[2]);\n\n  let prev, next, begin;\n\n  while (eventQueue.length !== 0) {\n    let event = eventQueue.pop();\n    sortedEvents.push(event);\n\n    // optimization by bboxes for intersection and difference goes here\n    if ((operation === INTERSECTION && event.point[0] > rightbound) ||\n        (operation === DIFFERENCE   && event.point[0] > sbbox[2])) {\n      break;\n    }\n\n    if (event.left) {\n      next  = prev = sweepLine.insert(event);\n      begin = sweepLine.minNode();\n\n      if (prev !== begin) prev = sweepLine.prev(prev);\n      else                prev = null;\n\n      next = sweepLine.next(next);\n\n      const prevEvent = prev ? prev.key : null;\n      let prevprevEvent;\n      computeFields(event, prevEvent, operation);\n      if (next) {\n        if (possibleIntersection(event, next.key, eventQueue) === 2) {\n          computeFields(event, prevEvent, operation);\n          computeFields(event, next.key, operation);\n        }\n      }\n\n      if (prev) {\n        if (possibleIntersection(prev.key, event, eventQueue) === 2) {\n          let prevprev = prev;\n          if (prevprev !== begin) prevprev = sweepLine.prev(prevprev);\n          else                    prevprev = null;\n\n          prevprevEvent = prevprev ? prevprev.key : null;\n          computeFields(prevEvent, prevprevEvent, operation);\n          computeFields(event,     prevEvent,     operation);\n        }\n      }\n    } else {\n      event = event.otherEvent;\n      next = prev = sweepLine.find(event);\n\n      if (prev && next) {\n\n        if (prev !== begin) prev = sweepLine.prev(prev);\n        else                prev = null;\n\n        next = sweepLine.next(next);\n        sweepLine.remove(event);\n\n        if (next && prev) {\n          possibleIntersection(prev.key, next.key, eventQueue);\n        }\n      }\n    }\n  }\n  return sortedEvents;\n}","import compareEvents from './compare_events';\nimport { DIFFERENCE, OperationType } from './operation';\nimport SweepEvent from './sweep_event';\nimport { Contour, Polygon, Point, MultiPolygon } from './types';\n\nfunction orderEvents(sortedEvents:SweepEvent[]) {\n  let event:SweepEvent, i, len, tmp;\n  const resultEvents = [];\n  for (i = 0, len = sortedEvents.length; i < len; i++) {\n    event = sortedEvents[i];\n    if ((event.left && event.inResult) ||\n      (!event.left && event.otherEvent.inResult)) {\n      resultEvents.push(event);\n    }\n  }\n  // Due to overlapping edges the resultEvents array can be not wholly sorted\n  let sorted = false;\n  while (!sorted) {\n    sorted = true;\n    for (i = 0, len = resultEvents.length; i < len; i++) {\n      if ((i + 1) < len &&\n        compareEvents(resultEvents[i], resultEvents[i + 1]) === 1) {\n        tmp = resultEvents[i];\n        resultEvents[i] = resultEvents[i + 1];\n        resultEvents[i + 1] = tmp;\n        sorted = false;\n      }\n    }\n  }\n\n\n  for (i = 0, len = resultEvents.length; i < len; i++) {\n    event = resultEvents[i];\n    event.pos = i;\n  }\n\n  // imagine, the right event is found in the beginning of the queue,\n  // when his left counterpart is not marked yet\n  for (i = 0, len = resultEvents.length; i < len; i++) {\n    event = resultEvents[i];\n    if (!event.left) {\n      tmp = event.pos;\n      event.pos = event.otherEvent.pos;\n      event.otherEvent.pos = tmp;\n    }\n  }\n\n  return resultEvents;\n}\n\n\nfunction nextPos(\n  pos:number, resultEvents:SweepEvent[],\n  processed:{ [index:number]: boolean }, origIndex:number\n):number {\n  console.log(resultEvents);\n  let p, p1;\n  let newPos = pos + 1;\n  const length = resultEvents.length;\n\n  p  = resultEvents[pos].point;\n\n  if (newPos < length) p1 = resultEvents[newPos].point;\n\n  // while in range and not the current one by value\n  while (newPos < length && p1[0] === p[0] && p1[1] === p[1]) {\n    if (!processed[newPos]) {\n      return newPos;\n    } else {\n      newPos++;\n    }\n    try {\n    p1 = resultEvents[newPos].point;\n    } catch (e) {\n      console.log(e, newPos, resultEvents.length);\n    }\n  }\n\n  newPos = pos - 1;\n\n  while (processed[newPos] && newPos >= origIndex) {\n    newPos--;\n  }\n  return newPos;\n}\n\n\nexport default function connectEdges(\n  sortedEvents:SweepEvent[], \n  operation:OperationType\n):MultiPolygon {\n  let i, len;\n  const resultEvents = orderEvents(sortedEvents);\n\n  // \"false\"-filled array\n  const processed:{[index:number]:boolean} = {};\n  const result:MultiPolygon = [];\n  let event;\n\n  for (i = 0, len = resultEvents.length; i < len; i++) {\n    if (processed[i]) continue;\n    const contour:Polygon = [[]];\n\n    if (!resultEvents[i].isExteriorRing) {\n      if (operation === DIFFERENCE && !resultEvents[i].isSubject && result.length === 0) {\n        result.push(contour);\n      } else if (result.length === 0) {\n        result.push([[]]);\n      } else {\n        result[result.length - 1].push(contour[0]);\n      }\n    } else if (operation === DIFFERENCE && !resultEvents[i].isSubject && result.length > 1) {\n      result[result.length - 1].push(contour[0]);\n    } else {\n      result.push(contour);\n    }\n\n    const ringId = result.length - 1;\n    let pos = i;\n\n    const initial:Point = resultEvents[i].point;\n    contour[0].push(initial);\n\n    while (pos >= i) {\n      event = resultEvents[pos];\n      processed[pos] = true;\n\n      if (event.left) {\n        event.resultInOut = false;\n        event.contourId   = ringId;\n      } else {\n        event.otherEvent.resultInOut = true;\n        event.otherEvent.contourId   = ringId;\n      }\n\n      pos = event.pos;\n      processed[pos] = true;\n      contour[0].push(resultEvents[pos].point);\n      pos = nextPos(pos, resultEvents, processed, i);\n    }\n\n    pos = pos === -1 ? i : pos;\n\n    event = resultEvents[pos];\n    processed[pos] = processed[event.pos] = true;\n    event.otherEvent.resultInOut = true;\n    event.otherEvent.contourId   = ringId;\n  }\n\n  // Handle if the result is a polygon (eg not multipoly)\n  // Commented it again, let's see what do we mean by that\n  // if (result.length === 1) result = result[0];\n  return result;\n}","import { MultiPolygon, BoundingBox } from './types';\nimport { \n  INTERSECTION, DIFFERENCE, UNION, XOR,\n  OperationType\n} from './operation';\nimport { EMPTY } from './constants';\nimport fillQueue from './fill_queue';\nimport subdivideSegments from './subdivide_segments';\nimport connectEdges from './connect_edges';\n\nfunction trivialOperation(\n  subject:MultiPolygon, \n  clipping:MultiPolygon, \n  operation:OperationType\n):MultiPolygon {\n  let result = null;\n  if (subject.length * clipping.length === 0) {\n    if        (operation === INTERSECTION) {\n      result = EMPTY;\n    } else if (operation === DIFFERENCE) {\n      result = subject;\n    } else if (operation === UNION ||\n               operation === XOR) {\n      result = (subject.length === 0) ? clipping : subject;\n    }\n  }\n  return result;\n}\n\n\nfunction compareBBoxes(\n  subject:MultiPolygon, clipping:MultiPolygon, \n  sbbox:BoundingBox, cbbox:BoundingBox, \n  operation:OperationType\n):MultiPolygon {\n  let result = null;\n  // they are far apart\n  if (sbbox[0] > cbbox[2] ||\n      cbbox[0] > sbbox[2] ||\n      sbbox[1] > cbbox[3] ||\n      cbbox[1] > sbbox[3]) {\n    if        (operation === INTERSECTION) { // no intersection possible\n      result = EMPTY;\n    } else if (operation === DIFFERENCE) { // take the subject\n      result = subject;\n    } else if (operation === UNION ||\n               operation === XOR) { // take both\n      result = subject.concat(clipping);\n    }\n  }\n  return result;\n}\n\n\nexport default function (\n  subject:MultiPolygon, \n  clipping:MultiPolygon, \n  operation:OperationType\n):MultiPolygon|null {\n  // 0. trivial cases\n  let trivial = trivialOperation(subject, clipping, operation);\n  if (trivial) {\n    return trivial === EMPTY ? null : trivial;\n  }\n  const sbbox:BoundingBox = [Infinity, Infinity, -Infinity, -Infinity];\n  const cbbox:BoundingBox = [Infinity, Infinity, -Infinity, -Infinity];\n\n  const eventQueue = fillQueue(subject, clipping, sbbox, cbbox, operation);\n\n  trivial = compareBBoxes(subject, clipping, sbbox, cbbox, operation);\n  if (trivial) {\n    return trivial === EMPTY ? null : trivial;\n  }\n\n  // 1. subdivide\n  //console.time('subdivide edges');\n  const sortedEvents = subdivideSegments(eventQueue, subject, clipping, sbbox, cbbox, operation);\n  //console.timeEnd('subdivide edges');\n\n  //console.time('connect vertices');\n  const result = connectEdges(sortedEvents, operation);\n  //console.timeEnd('connect vertices');\n  // 2. mark\n  // 3. connect\n  return result;\n}","import boolean from './boolean';\nimport {\n  INTERSECTION,\n  DIFFERENCE,\n  UNION,\n  XOR\n} from './operation';\nimport { MultiPolygon } from './types';\n\nexport function union (subject:MultiPolygon, clipping:MultiPolygon) {\n  return boolean(subject, clipping, UNION);\n}\n\nexport function diff (subject:MultiPolygon, clipping:MultiPolygon) {\n  return boolean(subject, clipping, DIFFERENCE);\n}\n\nexport function xor (subject:MultiPolygon, clipping:MultiPolygon){\n  return boolean(subject, clipping, XOR);\n}\n\nexport function intersection (subject:MultiPolygon, clipping:MultiPolygon) {\n  return boolean(subject, clipping, INTERSECTION);\n}\n\nexport const operations = { UNION, DIFFERENCE, INTERSECTION, XOR };\n"],"names":["let","const","Queue","y","subdivideSegments","intersection"],"mappings":"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"}