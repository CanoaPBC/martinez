{"code":"import divideSegment from './divide_segment';\r\nimport intersection from './segment_intersection';\r\nimport equals from './equals';\r\nimport compareEvents from './compare_events';\r\nimport { NON_CONTRIBUTING, SAME_TRANSITION, DIFFERENT_TRANSITION } from './edge_type';\r\n/**\r\n * @param  {SweepEvent} se1\r\n * @param  {SweepEvent} se2\r\n * @param  {Queue}      queue\r\n * @return {Number}\r\n */\r\nexport default function possibleIntersection(se1, se2, queue) {\r\n    // that disallows self-intersecting polygons,\r\n    // did cost us half a day, so I'll leave it\r\n    // out of respect\r\n    // if (se1.isSubject === se2.isSubject) return;\r\n    const inter = intersection(se1.point, se1.otherEvent.point, se2.point, se2.otherEvent.point, false);\r\n    const nintersections = inter ? inter.length : 0;\r\n    if (nintersections === 0)\r\n        return 0; // no intersection\r\n    // the line segments intersect at an endpoint of both line segments\r\n    if ((nintersections === 1) &&\r\n        (equals(se1.point, se2.point) ||\r\n            equals(se1.otherEvent.point, se2.otherEvent.point))) {\r\n        return 0;\r\n    }\r\n    if (nintersections === 2 && se1.isSubject === se2.isSubject) {\r\n        // if(se1.contourId === se2.contourId){\r\n        // console.warn('Edges of the same polygon overlap',\r\n        //   se1.point, se1.otherEvent.point, se2.point, se2.otherEvent.point);\r\n        // }\r\n        //throw new Error('Edges of the same polygon overlap');\r\n        return 0;\r\n    }\r\n    // The line segments associated to se1 and se2 intersect\r\n    if (nintersections === 1) {\r\n        // if the intersection point is not an endpoint of se1\r\n        if (!equals(se1.point, inter[0]) && !equals(se1.otherEvent.point, inter[0])) {\r\n            divideSegment(se1, inter[0], queue);\r\n        }\r\n        // if the intersection point is not an endpoint of se2\r\n        if (!equals(se2.point, inter[0]) && !equals(se2.otherEvent.point, inter[0])) {\r\n            divideSegment(se2, inter[0], queue);\r\n        }\r\n        return 1;\r\n    }\r\n    // The line segments associated to se1 and se2 overlap\r\n    const events = [];\r\n    let leftCoincide = false;\r\n    let rightCoincide = false;\r\n    if (equals(se1.point, se2.point)) {\r\n        leftCoincide = true; // linked\r\n    }\r\n    else if (compareEvents(se1, se2) === 1) {\r\n        events.push(se2, se1);\r\n    }\r\n    else {\r\n        events.push(se1, se2);\r\n    }\r\n    if (equals(se1.otherEvent.point, se2.otherEvent.point)) {\r\n        rightCoincide = true;\r\n    }\r\n    else if (compareEvents(se1.otherEvent, se2.otherEvent) === 1) {\r\n        events.push(se2.otherEvent, se1.otherEvent);\r\n    }\r\n    else {\r\n        events.push(se1.otherEvent, se2.otherEvent);\r\n    }\r\n    if ((leftCoincide && rightCoincide) || leftCoincide) {\r\n        // both line segments are equal or share the left endpoint\r\n        se2.type = NON_CONTRIBUTING;\r\n        se1.type = (se2.inOut === se1.inOut)\r\n            ? SAME_TRANSITION : DIFFERENT_TRANSITION;\r\n        if (leftCoincide && !rightCoincide) {\r\n            // honestly no idea, but changing events selection from [2, 1]\r\n            // to [0, 1] fixes the overlapping self-intersecting polygons issue\r\n            divideSegment(events[1].otherEvent, events[0].point, queue);\r\n        }\r\n        return 2;\r\n    }\r\n    // the line segments share the right endpoint\r\n    if (rightCoincide) {\r\n        divideSegment(events[0], events[1].point, queue);\r\n        return 3;\r\n    }\r\n    // no line segment includes totally the other one\r\n    if (events[0] !== events[3].otherEvent) {\r\n        divideSegment(events[0], events[1].point, queue);\r\n        divideSegment(events[1], events[2].point, queue);\r\n        return 3;\r\n    }\r\n    // one line segment includes the other one\r\n    divideSegment(events[0], events[1].point, queue);\r\n    divideSegment(events[3].otherEvent, events[2].point, queue);\r\n    return 3;\r\n}\r\n"}
