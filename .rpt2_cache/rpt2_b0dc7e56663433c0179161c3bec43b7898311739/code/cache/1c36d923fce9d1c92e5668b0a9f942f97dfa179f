{"code":"import Tree from 'splaytree';\r\nimport computeFields from './compute_fields';\r\nimport possibleIntersection from './possible_intersection';\r\nimport compareSegments from './compare_segments';\r\nimport { INTERSECTION, DIFFERENCE } from './operation';\r\nexport default function subdivide(eventQueue, subject, clipping, sbbox, cbbox, operation) {\r\n    const sweepLine = new Tree(compareSegments);\r\n    const sortedEvents = [];\r\n    const rightbound = Math.min(sbbox[2], cbbox[2]);\r\n    let prev, next, begin;\r\n    while (eventQueue.length !== 0) {\r\n        let event = eventQueue.pop();\r\n        sortedEvents.push(event);\r\n        // optimization by bboxes for intersection and difference goes here\r\n        if ((operation === INTERSECTION && event.point[0] > rightbound) ||\r\n            (operation === DIFFERENCE && event.point[0] > sbbox[2])) {\r\n            break;\r\n        }\r\n        if (event.left) {\r\n            next = prev = sweepLine.insert(event);\r\n            begin = sweepLine.minNode();\r\n            if (prev !== begin)\r\n                prev = sweepLine.prev(prev);\r\n            else\r\n                prev = null;\r\n            next = sweepLine.next(next);\r\n            const prevEvent = prev ? prev.key : null;\r\n            let prevprevEvent;\r\n            computeFields(event, prevEvent, operation);\r\n            if (next) {\r\n                if (possibleIntersection(event, next.key, eventQueue) === 2) {\r\n                    computeFields(event, prevEvent, operation);\r\n                    computeFields(event, next.key, operation);\r\n                }\r\n            }\r\n            if (prev) {\r\n                if (possibleIntersection(prev.key, event, eventQueue) === 2) {\r\n                    let prevprev = prev;\r\n                    if (prevprev !== begin)\r\n                        prevprev = sweepLine.prev(prevprev);\r\n                    else\r\n                        prevprev = null;\r\n                    prevprevEvent = prevprev ? prevprev.key : null;\r\n                    computeFields(prevEvent, prevprevEvent, operation);\r\n                    computeFields(event, prevEvent, operation);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            event = event.otherEvent;\r\n            next = prev = sweepLine.find(event);\r\n            if (prev && next) {\r\n                if (prev !== begin)\r\n                    prev = sweepLine.prev(prev);\r\n                else\r\n                    prev = null;\r\n                next = sweepLine.next(next);\r\n                sweepLine.remove(event);\r\n                if (next && prev) {\r\n                    possibleIntersection(prev.key, next.key, eventQueue);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return sortedEvents;\r\n}\r\n"}
