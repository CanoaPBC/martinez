{"code":"import compareEvents from './compare_events';\r\nimport { DIFFERENCE } from './operation';\r\n/**\r\n * @param  {Array.<SweepEvent>} sortedEvents\r\n * @return {Array.<SweepEvent>}\r\n */\r\nfunction orderEvents(sortedEvents) {\r\n    var event, i, len, tmp;\r\n    var resultEvents = [];\r\n    for (i = 0, len = sortedEvents.length; i < len; i++) {\r\n        event = sortedEvents[i];\r\n        if ((event.left && event.inResult) ||\r\n            (!event.left && event.otherEvent.inResult)) {\r\n            resultEvents.push(event);\r\n        }\r\n    }\r\n    // Due to overlapping edges the resultEvents array can be not wholly sorted\r\n    var sorted = false;\r\n    while (!sorted) {\r\n        sorted = true;\r\n        for (i = 0, len = resultEvents.length; i < len; i++) {\r\n            if ((i + 1) < len &&\r\n                compareEvents(resultEvents[i], resultEvents[i + 1]) === 1) {\r\n                tmp = resultEvents[i];\r\n                resultEvents[i] = resultEvents[i + 1];\r\n                resultEvents[i + 1] = tmp;\r\n                sorted = false;\r\n            }\r\n        }\r\n    }\r\n    for (i = 0, len = resultEvents.length; i < len; i++) {\r\n        event = resultEvents[i];\r\n        event.pos = i;\r\n    }\r\n    // imagine, the right event is found in the beginning of the queue,\r\n    // when his left counterpart is not marked yet\r\n    for (i = 0, len = resultEvents.length; i < len; i++) {\r\n        event = resultEvents[i];\r\n        if (!event.left) {\r\n            tmp = event.pos;\r\n            event.pos = event.otherEvent.pos;\r\n            event.otherEvent.pos = tmp;\r\n        }\r\n    }\r\n    return resultEvents;\r\n}\r\n/**\r\n * @param  {Number} pos\r\n * @param  {Array.<SweepEvent>} resultEvents\r\n * @param  {Object>}    processed\r\n * @return {Number}\r\n */\r\nfunction nextPos(pos, resultEvents, processed, origIndex) {\r\n    var p, p1;\r\n    var newPos = pos + 1;\r\n    var length = resultEvents.length;\r\n    p = resultEvents[pos].point;\r\n    if (newPos < length)\r\n        p1 = resultEvents[newPos].point;\r\n    // while in range and not the current one by value\r\n    while (newPos < length && p1[0] === p[0] && p1[1] === p[1]) {\r\n        if (!processed[newPos]) {\r\n            return newPos;\r\n        }\r\n        else {\r\n            newPos++;\r\n        }\r\n        p1 = resultEvents[newPos].point;\r\n    }\r\n    newPos = pos - 1;\r\n    while (processed[newPos] && newPos >= origIndex) {\r\n        newPos--;\r\n    }\r\n    return newPos;\r\n}\r\n/**\r\n * @param  {Array.<SweepEvent>} sortedEvents\r\n * @return {Array.<*>} polygons\r\n */\r\nexport default function connectEdges(sortedEvents, operation) {\r\n    var i, len;\r\n    var resultEvents = orderEvents(sortedEvents);\r\n    // \"false\"-filled array\r\n    var processed = {};\r\n    var result = [];\r\n    var event;\r\n    for (i = 0, len = resultEvents.length; i < len; i++) {\r\n        if (processed[i])\r\n            continue;\r\n        var contour = [[]];\r\n        if (!resultEvents[i].isExteriorRing) {\r\n            if (operation === DIFFERENCE && !resultEvents[i].isSubject && result.length === 0) {\r\n                result.push(contour);\r\n            }\r\n            else if (result.length === 0) {\r\n                result.push([[]]);\r\n            }\r\n            else {\r\n                result[result.length - 1].push(contour[0]);\r\n            }\r\n        }\r\n        else if (operation === DIFFERENCE && !resultEvents[i].isSubject && result.length > 1) {\r\n            result[result.length - 1].push(contour[0]);\r\n        }\r\n        else {\r\n            result.push(contour);\r\n        }\r\n        var ringId = result.length - 1;\r\n        var pos = i;\r\n        var initial = resultEvents[i].point;\r\n        contour[0].push(initial);\r\n        while (pos >= i) {\r\n            event = resultEvents[pos];\r\n            processed[pos] = true;\r\n            if (event.left) {\r\n                event.resultInOut = false;\r\n                event.contourId = ringId;\r\n            }\r\n            else {\r\n                event.otherEvent.resultInOut = true;\r\n                event.otherEvent.contourId = ringId;\r\n            }\r\n            pos = event.pos;\r\n            processed[pos] = true;\r\n            contour[0].push(resultEvents[pos].point);\r\n            pos = nextPos(pos, resultEvents, processed, i);\r\n        }\r\n        pos = pos === -1 ? i : pos;\r\n        event = resultEvents[pos];\r\n        processed[pos] = processed[event.pos] = true;\r\n        event.otherEvent.resultInOut = true;\r\n        event.otherEvent.contourId = ringId;\r\n    }\r\n    // Handle if the result is a polygon (eg not multipoly)\r\n    // Commented it again, let's see what do we mean by that\r\n    // if (result.length === 1) result = result[0];\r\n    return result;\r\n}\r\n"}
