{"code":"/**\r\n * Finds the magnitude of the cross product of two vectors (if we pretend\r\n * they're in three dimensions)\r\n *\r\n * @param {Object} a First vector\r\n * @param {Object} b Second vector\r\n * @private\r\n * @returns {Number} The magnitude of the cross product\r\n */\r\nfunction crossProduct(a, b) {\r\n    return (a[0] * b[1]) - (a[1] * b[0]);\r\n}\r\n/**\r\n * Finds the dot product of two vectors.\r\n *\r\n * @param {Object} a First vector\r\n * @param {Object} b Second vector\r\n * @private\r\n * @returns {Number} The dot product\r\n */\r\nfunction dotProduct(a, b) {\r\n    return (a[0] * b[0]) + (a[1] * b[1]);\r\n}\r\n/**\r\n * Finds the intersection (if any) between two line segments a and b, given the\r\n * line segments' end points a1, a2 and b1, b2.\r\n *\r\n * This algorithm is based on Schneider and Eberly.\r\n * http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf\r\n * Page 244.\r\n *\r\n * @param {Array.<Number>} a1 point of first line\r\n * @param {Array.<Number>} a2 point of first line\r\n * @param {Array.<Number>} b1 point of second line\r\n * @param {Array.<Number>} b2 point of second line\r\n * @param {Boolean=}       noEndpointTouch whether to skip single touchpoints\r\n *                                         (meaning connected segments) as\r\n *                                         intersections\r\n * @returns {Array.<Array.<Number>>|Null} If the lines intersect, the point of\r\n * intersection. If they overlap, the two end points of the overlapping segment.\r\n * Otherwise, null.\r\n */\r\nexport default function (a1, a2, b1, b2, noEndpointTouch) {\r\n    // The algorithm expects our lines in the form P + sd, where P is a point,\r\n    // s is on the interval [0, 1], and d is a vector.\r\n    // We are passed two points. P can be the first point of each pair. The\r\n    // vector, then, could be thought of as the distance (in x and y components)\r\n    // from the first point to the second point.\r\n    // So first, let's make our vectors:\r\n    const va = [a2[0] - a1[0], a2[1] - a1[1]];\r\n    const vb = [b2[0] - b1[0], b2[1] - b1[1]];\r\n    // We also define a function to convert back to regular point form:\r\n    /* eslint-disable arrow-body-style */\r\n    function toPoint(p, s, d) {\r\n        return [\r\n            p[0] + s * d[0],\r\n            p[1] + s * d[1]\r\n        ];\r\n    }\r\n    /* eslint-enable arrow-body-style */\r\n    // The rest is pretty much a straight port of the algorithm.\r\n    const e = [b1[0] - a1[0], b1[1] - a1[1]];\r\n    let kross = crossProduct(va, vb);\r\n    let sqrKross = kross * kross;\r\n    const sqrLenA = dotProduct(va, va);\r\n    //const sqrLenB  = dotProduct(vb, vb);\r\n    // Check for line intersection. This works because of the properties of the\r\n    // cross product -- specifically, two vectors are parallel if and only if the\r\n    // cross product is the 0 vector. The full calculation involves relative error\r\n    // to account for possible very small line segments. See Schneider & Eberly\r\n    // for details.\r\n    if (sqrKross > 0 /* EPS * sqrLenB * sqLenA */) {\r\n        // If they're not parallel, then (because these are line segments) they\r\n        // still might not actually intersect. This code checks that the\r\n        // intersection point of the lines is actually on both line segments.\r\n        const s = crossProduct(e, vb) / kross;\r\n        if (s < 0 || s > 1) {\r\n            // not on line segment a\r\n            return null;\r\n        }\r\n        const t = crossProduct(e, va) / kross;\r\n        if (t < 0 || t > 1) {\r\n            // not on line segment b\r\n            return null;\r\n        }\r\n        if (s === 0 || s === 1) {\r\n            // on an endpoint of line segment a\r\n            return noEndpointTouch ? null : [toPoint(a1, s, va)];\r\n        }\r\n        if (t === 0 || t === 1) {\r\n            // on an endpoint of line segment b\r\n            return noEndpointTouch ? null : [toPoint(b1, t, vb)];\r\n        }\r\n        return [toPoint(a1, s, va)];\r\n    }\r\n    // If we've reached this point, then the lines are either parallel or the\r\n    // same, but the segments could overlap partially or fully, or not at all.\r\n    // So we need to find the overlap, if any. To do that, we can use e, which is\r\n    // the (vector) difference between the two initial points. If this is parallel\r\n    // with the line itself, then the two lines are the same line, and there will\r\n    // be overlap.\r\n    //const sqrLenE = dotProduct(e, e);\r\n    kross = crossProduct(e, va);\r\n    sqrKross = kross * kross;\r\n    if (sqrKross > 0 /* EPS * sqLenB * sqLenE */) {\r\n        // Lines are just parallel, not the same. No overlap.\r\n        return null;\r\n    }\r\n    const sa = dotProduct(va, e) / sqrLenA;\r\n    const sb = sa + dotProduct(va, vb) / sqrLenA;\r\n    const smin = Math.min(sa, sb);\r\n    const smax = Math.max(sa, sb);\r\n    // this is, essentially, the FindIntersection acting on floats from\r\n    // Schneider & Eberly, just inlined into this function.\r\n    if (smin <= 1 && smax >= 0) {\r\n        // overlap on an end point\r\n        if (smin === 1) {\r\n            return noEndpointTouch ? null : [toPoint(a1, smin > 0 ? smin : 0, va)];\r\n        }\r\n        if (smax === 0) {\r\n            return noEndpointTouch ? null : [toPoint(a1, smax < 1 ? smax : 1, va)];\r\n        }\r\n        if (noEndpointTouch && smin === 0 && smax === 1)\r\n            return null;\r\n        // There's overlap on a segment -- two points of intersection. Return both.\r\n        return [\r\n            toPoint(a1, smin > 0 ? smin : 0, va),\r\n            toPoint(a1, smax < 1 ? smax : 1, va)\r\n        ];\r\n    }\r\n    return null;\r\n}\r\n"}
